### 1. 앱 만들기

- **react 처럼 id app에 마운트된다.**
- 메인 소스에서 app.component('TestComponent', TestComponent) 선언하면, **전역 컴포넌트 설정 가능**
- **메인 소스에서 전역 에러 캡처링도 가능** 
- 멀티 앱 인스턴스

```ts
	app.config.errorHandler = (err) => {
	/* 에러 처리 */
	console.log('error', err)
	}
```

```html
<!DOCTYPE html>

<html lang="">
<head>
	<meta charset="UTF-8">
	<link rel="icon" href="/favicon.ico">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Vite App</title>
</head>

<body>
	<div id="app"></div>
		<script type="module" src="/src/main.ts"></script>
	</body>
</html>

```

```ts

import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import TestComponent from './components/TestComponent.vue'

const app = createApp(App)

app.config.errorHandler = (err) => {
/* 에러 처리 */
console.log('error', err)
}

app.component('TestComponent', TestComponent)

app.use(router)



  
// 마운트
app.mount('#app')
```

### 2. 템플릿 문법
- **리액트랑 거의 유사하다, 단 {{}} 이중괄호**

1) HTML 출력
react의 dangerousSetInnterHTML 처럼, v-html 사용
```
<p>텍스트 보간법 사용: {{ rawHtml }}</p> 
<p>v-html 디렉티브 사용: <span v-html="rawHtml"></span></p>


텍스트 보간법 사용: <span style="color: red">이것은 빨간색이어야 합니다.</span>
v-html 디렉티브 사용: 이것은 빨간색이어야 합니다.

```

2) 속성 바인딩
- **이중괄호는 HTML 속성(attribute) 내에서 사용할 수 없다! 대신 v-bind 디렉티브를 사용해라**
- 바인딩된 값이 null 또는 undefined이면 엘리먼트의 속성이 제거된 상태로 렌더된다.

```html

<div v-bind:id="dynamicId"></div>

```

**단축 문법**
```html

<div :id="dynamicId"></div>

```

**동일 이름 축약**
- 속성의 이름이 바인딩되는 자바스크립트의 값과 같을 경우, 속성 값 생략을 통해 문법을 더욱 간소화 할 수 있다.
```html

<!-- :id="id" 와 동일 -->
<div :id></div>

<!-- 이것도 작동합니다 -->
<div v-bind:id></div>
<div v-bind:id="id"></div>

```

**불리언(Boolean) 속성**
- [불리언 속성](https://html.spec.whatwg.org/multipage/common-microsyntaxes#boolean-attributes)은 엘리먼트에 표기했는지 여부로 참/거짓 값을 나타내는 속성입니다. 예를 들어, [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled)는 가장 일반적으로 사용되는 불리언 속성 중 하나입니다.

```html

<button :disabled="isButtonDisabled">버튼/button>

```

`isButtonDisabled`에 [truthy 값](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)이 있는 경우, `disabled` 속성이 표기됩니다. 값이 빈 문자열인 경우 `<button disabled="">`의 일관성을 유지하므로 속성이 표기됩니다. 그 외 [falsy 값](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)의 경우 속성이 생략됩니다.

**여러 속성을 동적으로 바인딩**

```ts

const objectOfAttrs = 
{ id: 'container', class: 'wrapper', style: 'background-color:green' }

```

```html

<div v-bind="objectOfAttrs"></div>

```


2) JavaScript 표현식 사용

**표현식 사용**
```ts

{{ number + 1 }}

{{ ok ? '예' : '아니오' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>

```

**함수호출**
- 바인딩 표현식 내부에서 컴포넌트에서 노출하는 메서드를 호출할 수 있다.

```typescript

<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>

```

**제한된 전역 접근**
- 템플릿 표현식은 샌드박스 처리되어 [제한된 전역 리스트](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3)에만 접근할 수 있습니다. 이 목록은 `Math` 및 `Date` 등 일반적으로 사용되는 기본 제공 전역 객체를 표시합니다.
- 리스트에 명시적으로 포함되지 않은 `window`와 같은 전역 속성은 템플릿 표현식에서 접근할 수 없습니다. 그러나 [`app.config.globalProperties`](https://ko.vuejs.org/api/application.html#app-config-globalproperties)에 추가하여, Vue 내부의 모든 표현식에서 전역 속성에 접근 할 수 있도록 명시적으로 정의할 수 있습니다.

템플릿 안에서 window 접근하면 요래됨

![[Pasted image 20250604134839.png]]

2) 디렉티브
- v- 접두사가 있는 특수한 속성을 디렉티브라 한다. Vue는 위에서 언급한 v-html, v-bind를 포함하여 빌트인 디렉티브를 제공한다.
- **디렉티브의 속성 값은 단일 JavaScript 표현식이어야 한다(v-for, v-on, v-slot 제외)**
- 디렉티브의 역할을 표현식 값이 변경될 때 DOM에 반응적으로 업데이트를 적용하는것
- **디렉티브의 인자를 대괄호로 감싸서 JavaScript 표현식으로 사용할 수도 있습니다:**

**인자** 
일부 디렉티브는 디렉티브 뒤에 콜론(`:`)으로 표시되는 "인자"를 사용할 수 있습니다. 예를 들어 `v-bind` 디렉티브는 HTML 속성을 반응적으로 업데이트하는 데 사용됩니다:

```html
<a v-bind:href="url"> ... </a>

<!-- 단축 문법 -->
<a :href="url"> ... </a>
```

```html
<a v-on:click="doSomething"> ... </a>
<!-- 단축 문법 -->
<a @click="doSomething"> ... </a>
```

**동적인 인자**
- 디렉티브의 인자를 대괄호로 감싸서 JavaScript 표현식으로 사용할 수도 있습니다:
- 동적인 인자 값 제약 조건[​](https://ko.vuejs.org/guide/essentials/template-syntax.html#dynamic-argument-value-constraints)
	**동적인 인자는 `null` 또는 문자열로 평가되어야 합니다. 값이 `null`일 경우, 바인딩을 명시적으로 제거합니다. 문자열이 아닌 다른 값은 에러를 트리거합니다.**
- 동적인 인자 문법 제약 조건
```html

<!-- 이렇게 하면 컴파일러 경고가 트리거됩니다. -->
<a :['foo' + bar]="value"> ... </a>

```
- DOM 내 템플릿(HTML 파일에 직접 작성된 템플릿)을 사용할 때, 브라우저가 속성 이름을 소문자로 강제 변환하므로 대문자로 키 이름을 지정하는 것도 피해야 합니다:

```html

<a :[someAttr]="value"> ... </a>

```

위의 내용은 DOM 내 템플릿에서 `:[someattr]`로 변환됩니다. 컴포넌트에 `someattr` 대신 `someAttr` 속성을 사용했다면 코드가 작동하지 않습니다. 싱글 파일 컴포넌트 내의 템플릿은 이 제약 조건에 해당하지 않습니다.

대문자로 속성이 들어가도, 소문자로 자동으로 파싱된다(무적권)
```vue

<script setup lang="ts">
const triggerError = () => {
// throw new Error('error')
console.log(window)
}

  

const LINK = 'HrEF'
const route = '/home'
</script>

  

<template>
	<a :[LINK]="route"> ... </a>
</template>

```

![[Pasted image 20250604140612.png]]
```html
<!--
아래의 "동적인 인자 값 제약 조건" 및 "동적인 인자 문법 제약 조건" 섹션에 설명된 대로,
인자 표현식에는 몇 가지 제약 사항이 있음에 유의하십시오.
-->
<a v-bind:[attributeName]="url"> ... </a>

<!-- 단축 문법 -->
<a :[attributeName]="url"> ... </a>

```

```html

<a v-on:[eventName]="doSomething"> ... </a>

<!-- 단축 문법 -->
<a @[eventName]="doSomething"> ... </a>

```

3) 수식어
- 수식어는 점(`.`)으로 시작하는 특수한 접미사로, 디렉티브가 특별한 방식으로 바인딩되어야 함을 나타냅니다. 예를 들어 `.prevent` 수식어는 트리거된 이벤트에서 `event.preventDefault()`를 호출하도록 `v-on` 디렉티브에 지시합니다.

```html
<form @submit.prevent="onSubmit">...</form>
```

![[Pasted image 20250604141017.png]]
### 3. 반응형 기초

1) reactive

- react의 useState와 다른점: 불변성 개념이 없다.
**(Vue는 기본적으로 반응형 상태를 내부 깊숙이 추적하므로, 중첩된 객체나 배열을 변경할 때에도 변경 사항이 감지된다)**
- reactive는 원시값을 사용할 수 없다(객체, 배열, Map, Set)과 같은 컬렉션 유형에만 사용가능
- **<mark style="background: #FFB8EBA6;">반응형 객체의 속성을 로컬 변수에 할당하거나 분해 할당 또는 함수에 전달할 때 반응형 연결이 끊어짐을 의미합니다.</mark>**
-  **반응형 객체의 속성을 로컬 변수에 할당하거나 분해 할당 또는 함수에 전달할 때 반응형 연결이 끊어짐을 의미합니다.**

```ts

const state = reactive({ count: 0 })

// n은 state.count에서 연결이 끊긴 로컬 변수입니다.
let n = state.count
// 원본의 상태(state.count)에 영향을 미치지 않습니다.
n++

// 로컬 변수 count는 state.count로부터 연결이 끊깁니다.
let { count } = state
// 원본의 상태(state.count)에 영향을 미치지 않습니다.
count++

// 함수는 일반적인 숫자를 수신하며,
// state.count의 변경 사항을 감지할 수 없습니다.
callSomeFunction(state.count)

```

```ts

import {reactive} from 'vue';

const state = reactive({ count: 0})

```

```ts

<script setup>
import { reactive } from 'vue'

const state = reactive({ count: 0 })

function increment() {
  state.count++
}
</script>

<template>
  <button @click="increment">
    {{ state.count }}
  </button>
</template>

```

**DOM 업데이트 타이밍**
DOM 업데이트는 동기적으로 업데이트 되지 않는다.

```ts

import { nextTick } from 'vue'

function increment() {
  state.count++
  nextTick(() => {
    // 업데이트된 DOM에 접근 가능
  })
}

```

**깊은 반응형**

#### **<mark style="background: #FFB8EBA6;">Vue는 기본적으로 반응형 상태를 내부 깊숙히 추적하므로, 충접된 객체나 배열을 변경할 때에도 변경 사항이 감지된다.</mark>**
##### **<mark style="background: #FFB8EBA6;">Vue는 기본적으로 반응형 상태를 내부 깊숙히 추적하므로, 충접된 객체나 배열을 변경할 때에도 변경 사항이 감지된다.</mark>**
###### **<mark style="background: #FFB8EBA6;">Vue는 기본적으로 반응형 상태를 내부 깊숙히 추적하므로, 충접된 객체나 배열을 변경할 때에도 변경 사항이 감지된다.</mark>**

```ts

import { reactive } from 'vue'

const obj = reactive({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // 변경 사항이
  obj.nested.count++
  obj.arr.push('baz')
}

```

만약 root 수준에서만 반응성을 추적하는 얕은 반응형 객체를 명시적으로 선언하려면 (shallowReactive)

**반응형 재정의 vs 원본**
reactive()의 반환 값은 원본 객체와 같지 않고 원본 객체를 재정의한 Proxy 객체를 반환한다.

```ts
const raw = {}
const proxy = reactive(raw)

// 반응형으로 재정의 된 것은 원본과 같지 않습니다.
console.log(proxy === raw) // false
```

#### <mark style="background: #FFB8EBA6;">1) 원본 객체를 업데이트하면, Proxy 객체도 업데이트 된다.(단 리렌더링은 안된다.)</mark>
#### <mark style="background: #FFB8EBA6;">2) Proxy 객체를 업데이트 하면 리렌더링 된다.
</mark>
```ts


<script setup>

import { ref, reactive } from 'vue'

const testObj = {number: 0};
const test1 = reactive(testObj)

const checkValue = () => {
	console.log("testObj", testObj)
	console.log("test1", test1)
}

const updateOriginValue = () => {
	testObj.number +=1;
}

const updateReactiveValue = () => {
	test1.number+=1;
}

</script>

<template>
	<h2>{{test1.number}}</h2>
	<button @click="checkValue">checkValue</button>
	<button @click="updateOriginValue">updateOriginValue</button>
	<button @click="updateReactiveValue">updateReactiveValue</button>
</template>

```

#### 3) <mark style="background: #FFB8EBA6;">Proxy를 Proxy하면 동일한 Proxy를 반환한다.</mark>
```ts

const raw = {}
const proxy = reactive(raw)

// 반응형으로 재정의 된 것은 원본과 같지 않습니다.
console.log(proxy === raw) // false

// 객체를 reactive() 한 반환 값과 프락시는 동일합니다.
console.log(reactive(raw) === proxy) // true

// 프락시를 reactive()한 반환 값과 프락시는 동일합니다.
console.log(reactive(proxy) === proxy) // true



```

#### <mark style="background: #FFB8EBA6;">4) 3의 중첩 규칙은 중첩된 객체에도 적용된다. (내부 깊숙이까지 반응형이므로 반응형 객체 내부의 중첩된 객체도 프록시다.) </mark>

```ts
const proxy = reactive({})

const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false

```

2) ref

- reactive의 자료형 제약사항을 해결하기 위해 어떠한 데이터라도 반응형으로 재정의 할 수 있다.
- reactive와 다르게 구조분해 할당해도 반응형이 끊기지 않는다.

```ts

import { ref } from 'vue'

const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

```

### 4. 계산된 속성(computed)
- 템플릿 내 표현식은 매우 편리하지만, 템플릿 내 너무 많은 논리를 넣으면 비대해진다.
- 이를 위해 computed를 사용한다.

```vue
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// 계산된 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>책을 가지고 있다:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```

1. computed를 통해 반환되는 값은 computed ref 다
2. 일반 ref와 유사하게 계산된 결과를 publishedBooksMessage.value로 접근할 수 있다.
3. template에서는 마찬가지로 언래핑되므로 .value 없이 참고할 수 있다.

**수정 가능한 계산된 속성**

```vue
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 참고: 분해 할당 문법을 사용함.
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```

**주의점**
- <mark style="background: #FF5582A6;">Getters should be side-effect free</mark>
- <mark style="background: #FF5582A6;">Avoid mutating computed value (의존성 배열을 업데이트해서 computed 값을 업데이트 해야지, 직접 computed.value를 업데이트하면 안된다.)</mark>

### 5. 클래스와 스타일 바인딩

**객체로 바인딩 하기**

```html

<div :class="{ active: isActive }"></div>

```
- <mark style="background: #FFB8EBA6;">isActive의 boolean을 통해 active 클래스의 존재 여부가 결정될 수 있다.</mark>
- 객체에 더 많은 필드를 사용하여 여러 클래스를 토글할 수 있다.

```js
<script>

const isActive = ref(true);
const hasError = ref(false);

</script>


<template>
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>
</template>

```

결과)
```js

<template>
	<div class="static active"></div>
</template>

```

- reactivity를 사용한 객체로 클래스 바인딩

```js
<script>
	const classObject = reactive({
	  active: true,
	  'text-danger': false
	})
</script>

<template>
	<div :class="classObject"></div>
</template>
```

- computed를 통한 속성 바인딩
```js
<script>
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
</script>

<template>
	<div :class="classObject"></div>
</template>

```

**배열로 바인딩 하기**
:class 를 배열로 바인딩하여 클래스 목록을 적용할 수도 있다.

```js
<script>

const activeClass = ref('active')
const errorClass = ref('text-danger')

</script>

<template>

<div :class="[activeClass, errorClass]"></div>

</template>

```

결과) 
```js
<div class="active text-danger"></div>
```

- 삼항 표현식을 사용하여 목록 내 클래스 토글하기

```js

<div :class="[isActive ? activeClass : '', errorClass]"></div>


```

- 배열 구문 내에서 객체구문 사용하기

```js

<div :class="[{ active: isActive }, errorClass]"></div>

```


**컴포넌트에서 사용하기**

- <mark style="background: #FFF3A3A6;">최상위(root) 엘리먼트가 하나로 구성된 컴포넌트에서 `class` 속성을 사용하면, 해당 클래스가 컴포넌트의 루트 엘리먼트에 이미 정의된 기존 클래스와 병합되어 추가됩니다.</mark>

```js
<template>
	<!-- 자식 컴포넌트의 템플릿 -->
	<p class="foo bar">안녕!</p>
</template>
```

```js
<template>
	<!-- 컴포넌트가 사용될 때 -->
	<MyComponent class="baz boo" />
</template>
```

<mark style="background: #FFF3A3A6;">아래처럼 렌더링된다.</mark>

```js

<p class="foo bar baz boo">안녕!</p>

```

- <mark style="background: #FFF3A3A6;">클래스 바인딩도 마찬가지다!</mark>

```js
<MyComponent :class="{ active: isActive }" />
```

```js

<p class="foo bar active">안녕!</p>

```

##### <mark style="background: #ABF7F7A6;">여러 개의 최상위 엘리먼트로 컴포넌트가 구성되어 있는 경우, 클래스를 적용할 엘리먼트를 정의해야 합니다. `$attrs` 컴포넌트 속성을 사용하여 이 작업을 수행할 수 있습니다.</mark>

###### <mark style="background: #ABF7F7A6;">여러 개의 최상위 엘리먼트로 컴포넌트가 구성되어 있는 경우, 클래스를 적용할 엘리먼트를 정의해야 합니다. `$attrs` 컴포넌트 속성을 사용하여 이 작업을 수행할 수 있습니다.</mark>

```js

<!-- MyComponent 템플릿에서 $attrs 속성을 사용 -->
<p :class="$attrs.class">안녕!</p>
<span>반가워!</span>

```

```js
<MyComponent class="baz" />
```

<mark style="background: #FFF3A3A6;">결과)</mark>
```js
<p class="baz">Hi!</p>
<span>반가워!</span>
```


**인라인 스타일링 바인딩**

- 클래스 바인딩과 유사하다.
```js

<script>

	const activeColor = ref('red')
	const fontSize = ref(30)

</script>

<template>

	<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

</template>

```

- camelCase가 권장되지만 kebab 케이스도 지원한다.

```js
<div :style="{ 'font-size': fontSize + 'px' }"></div>
```

- 클래스 바인딩과 마찬가지로, 깔끔하게 객체를 직접 바인딩하는 것이 좋다.
(+ computed properties)
```js

<script>
const styleObject = reactive({
  color: 'red',
  fontSize: '13px'
})
</script>

<template>

<div :style="styleObject"></div>

</template>


```

- 배열로 바인딩하기

```js
<div :style="[baseStyles, overridingStyles]"></div>
```

- <mark style="background: #ADCCFFA6;">접두사 자동완성</mark>
<mark style="background: #FFF3A3A6;">Vue가 실행되고 있을 때, 해당 브라우저에서 지원되지 않는 CSS 속성이 :style에 사용되면 자동으로 해당 속성과 벤더 접두사가 조합된 여러 개의 특수한 속성을 테스트하고 지원되는 속성을 찾아서 추가한다.</mark>

- 다중값

```js
<div :style="{ display: ['flex', '-webkit-box', '-ms-flexbox'] }"></div>
```
이 경우, 브라우저가 지원하는 배열 내 마지막 값을 렌더링합니다. <mark style="background: #ABF7F7A6;">이 예제에서 브라우저가 `flex`와 `-webkit-box` 속성만 지원한다면, `flex`라는 표준 속성 값이 있음에도 `display: -webkit-box`를 렌더링 합니다.</mark>


### 6. 조건부 렌더링

1) v-if
2) v-else
3) v-else-if

```js

<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  A/B/C 아님
</div>

```

4) <mark style="background: #FFB86CA6;">template에서 v-if</mark>
	v-if는 디렉티브이므로 단일 엘리먼트에 연결해야 한다. 하지만 둘 이상의 엘리먼트를 전환하려면 어떻게 해야할까? 
	
	<mark style="background: #FFB8EBA6;">template에 v-if를 사용하면 된다.</mark>
	React.Fragment와 비슷하며, 렌더링되면 template은 사라진다.
	
	<mark style="background: #FFB8EBA6;">template에서도 v-else, v-else-if 사용 가능하다</mark>

```js
<template v-if="ok">
  <h1>제목</h1>
  <p>단락 1</p>
  <p>단락 2</p>
</template>
```

5) v-show
- <mark style="background: #FF5582A6;">v-if와 차이점은 v-if가 있는 엘리먼트는 항상 렌더링되고 DOM에 남아있다. (엘리먼트의 display css 속성만 변경한다.)</mark>
-  <mark style="background: #FF5582A6;">v-show는 template 엘리먼트를 지원하지 않으며 v-else와 상호작용하지 않는다.</mark>

<mark style="background: #FFB8EBA6;">v-if vs v-show</mark>
- 일반적으로 `v-if`는 전환 비용이 더 높고, `v-show`는 초기 렌더링 비용이 더 높습니다. 따라서 매우 자주 전환해야 하는 경우 `v-show`를, 실행 중에 조건이 변경되지 않는 경우 `v-if`를 사용하는 것이 좋습니다.

<mark style="background: #FFB8EBA6;">v-if with v-for</mark>
- `v-if`와 `v-for`를 함께 사용하는 것은 **권장되지 않습니다**. (https://v3-docs.vuejs-korea.org/style-guide/rules-essential.html#avoid-v-if-with-v-for)
### 7. 리스트 렌더링

**v-for**

- v-for 디렉티브로 배열을 렌더링할 수 있다.
- item in items 문법

```js

<script>
	const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
</script>

<template>
	<li v-for="item in items">
	  {{ item.message }}
	</li>
</template>
```

- v-for 범위 내 템플릿 범위 내 표현식은 상위 범위 속성에 접근할 수 있으며 v-for에서 현재 아이템의 인덱스를 가리키는 두 번째 별칭도 지원한다.
```js
<script>
	const parentMessage = ref('Parent')
	const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
</script>

<template>
	<li v-for="(item, index) in items">
	  {{ parentMessage }} - {{ index }} - {{ item.message }}
	</li>
</template>

```

- 분해 할당도 가능하다.
```js

<li v-for="{ message } in items">
  {{ message }}
</li>

<!-- index 별칭도 사용 -->
<li v-for="({ message }, index) in items">
  {{ message }} {{ index }}
</li>

```

- 중첩된 v-for의 경우, 중첩된 함수와 유사한 범위를 가진다. (상위 접근 가능)

```js

<li v-for="item in items">
  <span v-for="childItem in item.children">
    {{ item.message }} {{ childItem }}
  </span>
</li>


```

- in 대신 of로 구분 기호로 사용 가능

```js

<div v-for="item of items"></div>

```

**객체에 v-for 사용하기**

```js

<script>

const myObject = reactive({
  title: 'Vue에서 목록을 작성하는 방법',
  author: '홍길동',
  publishedAt: '2016-04-10'
})


</script>

<template>
	<ul>
	  <li v-for="value in myObject">
	    {{ value }}
	  </li>
	</ul>

	<ul>
		<li v-for="(value, key) in myObject">
		  {{ key }}: {{ value }}
		</li>
	</ul>

	<ul>
		<li v-for="(value, key, index) in myObject">
			{{ index }}. {{ key }}: {{ value }}
		</li>
	</ul>
</template>

```

**숫자 범위에 v-for 사용하기**
- <mark style="background: #FFB8EBA6;">v-for는 정수를 사용할 수 있으며, 1...n 범위를 기준으로 반복한다. (0이 아니라 1부터)</mark>

```js
<span v-for="n in 10">{{ n }}</span>
```

**`<template>`에서 `v-for` 사용하기**
- v-if와 유사하게 `<template>` 태그에 v-for를 사용하여 렌더링 가능하다.

```js

<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>


```


**`v-for` with `v-if`**
- v-if가 v-for보다 높은 우선 순위를 가진다. (That means the `v-if` condition will not have access to variables from the scope of the `v-for`:)

```js

<!--
This will throw an error because property "todo"
is not defined on instance.
-->

<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>

```

FIX)

```js
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>

```

<mark style="background: #FF5582A6;">주의</mark>
- It's **not** recommended to use `v-if` and `v-for` on the same element due to implicit precedence.

1) To filter items in a list (e.g. `v-for="user in users" v-if="user.isActive"`). In these cases, replace `users` with a new computed property that returns your filtered list (e.g. `activeUsers`).

2) To avoid rendering a list if it should be hidden (e.g. `v-for="user in users" v-if="shouldShowUsers"`). In these cases, move the `v-if` to a container element (e.g. `ul`, `ol`).


**키를 통한 상태 유지(Maintaining State with key)**
- v-for로 렌더링된 리스트를 업데이트할 때, 기본적으로 "in-place patch"전략을 사용한다.

-><mark style="background: #FFF3A3A6;"> 리스트 아이템의 순서가 변경된 경우, 아이템의 순서와 일치하도록 DOM 엘리먼트를 이동하는대신 변경이 필요한 인덱스의 엘리먼트들을 제자리에서 패치해 아이템을 렌더링한다.</mark>

-> <mark style="background: #FFF3A3A6;">위와 같은 동작은 효율적이지만, 리스트 렌더링 출력이 자식 컴포넌트 상태 또는 임시 DOM(예: 양식 입력 값)에 의존하지 않는 경우에만 유효하다.</mark>

-> <mark style="background: #FFF3A3A6;">Vue 각 노드의 ID를 추적하고 기존 엘리먼트를 재사용하고 재정렬할 수 있도록 힌트를 제공하려면 각 항목에 대해 고유한 key 속성을 제공해야 한다.</mark>

```js

<div v-for="item in items" :key="item.id">
  <!-- content -->
</div>

```

```js

<template v-for="todo in todos" :key="todo.name">
  <li>{{ todo.name }}</li>
</template>

```


**v-for with a Component**
- 컴포넌트와 v-for 같이 사용할 때

```js

<MyComponent v-for="item in items" :key="item.id" />

```

props가 있다면?

```js

<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>

```


**배열 변경 감지**
- **vue에서는 반응형 배열의 변경 메소드가 호출되는 것을 감지하여, 필요한 업데이트를 발생시킨다.**
(reactivity 로직에 의해 proxy를 통해서 proxy 배열이 바뀔 때 원본 배열도 같이 바뀜)

- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()

**배열 교체**
- 아래 메서드는 항상 새 배열을 반환하므로, 이전 배열을 새 배열로 교체해야한다.

- filter()
- concat()
- slice()

**필터링/정렬 결과 표시**
- 원본 데이터를 실제로 수정하거나 교체하지 않고, 필터링되거나 정렬된 결과를 표시하고 싶을 때는 computed 속성 사용

```js

<script>

	const numbers = ref([1, 2, 3, 4, 5])
	
	const evenNumbers = computed(() => {
	  return numbers.value.filter((n) => n % 2 === 0)
	})

</script>

<template>

	<li v-for="n in evenNumbers">{{ n }}</li>

</template>

```


- 계산된 속성이 실현 가능하지 않은 상황(예: 중첩된 `v-for` 루프 내부)에서는 다음과 같은 방법으로 해결할 수 있습니다:
```js

<script>
const sets = ref([
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10]
])

function even(numbers) {
  return numbers.filter((number) => number % 2 === 0)
}
</script>

<template>
	<ul v-for="numbers in sets">
	  <li v-for="n in even(numbers)">{{ n }}</li>
	</ul>
</template>

```

<mark style="background: #FF5582A6;">주의)</mark>
계산된 속성에서 `reverse()`와 `sort()` 사용에 주의하십시오! 이 두 가지 방법은 원본 배열을 수정하므로 계산된 속성의 getter 함수에서 피해야합니다. 다음 메서드를 호출하기 전에 원본 배열의 복사본을 만듭니다: (당연)

```diff
- return numbers.reverse()
+ return [...numbers].reverse()
```
### 8. 이벤트 핸들링

1) 이벤트 리스닝하기
- `v-on`디렉티브는 단축 문법으로 `@`기호를 사용하며, DOM 이벤트를 수신하고 트리거될 때 사전에 정의해둔 JavaScript 코드를 실행할 수 있다. 
### `v-on:click="handler"` 또는 줄여서 `@click="handler"` 사용한다.

- 핸들러의 값은 다음 중 하나일 수 있다
	1) 인라인 핸들러: 이벤트가 트리거될 떄 실행되는 인라인 JavaScript (네이티브 onclick 속성과 유사)
	2) 메서드 핸들러: 컴포넌트에 정의된 메서드 이름 또는 메서드를 가리키는 경로


**인라인 핸들러**
- 인라인 핸들러는 일반적으로 간단한 경우에 사용

```js

<script>
	const count = ref(0)
</script>


<template>
	<button @click="count++">1 추가</button>
	<p>숫자 값은: {{ count }}</p>
</template>


```

**메서드 핸들러**
- 대부분의 이벤트 핸들러 논리는 복잡할 것이며, 인라인 핸들러에서는 실현 가능하지 않을 수 있다. -> 이때 메서드 핸들러 사용

```js

<script>
const name = ref('Vue.js')

function greet(event) {
  alert(`안녕 ${name.value}!`)
  // 'event'는 네이티브 DOM 이벤트 객체입니다.
  if (event) {
    alert(event.target.tagName)
  }
}
</script>

<template>
	<!-- `greet`는 위에서 정의한 메서드의 이름입니다. -->
	<button @click="greet">환영하기</button>
</template>


```

-> `event.target.tagName`을 통해 이벤트를 전달하는 엘리먼트에 접근할 수 있다.

**메서드 vs 인라인 구분**

템플릿 컴파일러는 `v-on` 값인 문자열이 유효한 JavaScript 식별자 또는 속성에 접근 가능한 경로인지 확인해서 메서드 핸들러를 감지한다.
( 예를 들어 `foo`, `foo.bar` 및 `foo['bar']`는 메서드 핸들러로 처리되는 반면, `foo()` 및 `count++`는 인라인 핸들러로 처리됩니다.)

**인라인 핸들러에서 메서드 호출하기**
```js
<script>
	function say(message) {
	  alert(message)
	}
</script>

<template>
	<button @click="say('안녕')">안녕이라고 말하기</button>
	<button @click="say('잘가')">잘가라고 말하기</button>
</template>
```

**인라인 핸들러에서 이벤트 객체 접근하기**
- 인라인 핸들러에서 네이티브 DOM 이벤트 객체에 접근하고 싶다면?
	1) 특수 키워드 `$event`
	2) 인라인 화살표 함수


```js
<script>
	function warn(message, event) {
	  // 이제 네이티브 이벤트 객체에 접근할 수 있습니다.
	  if (event) {
	    event.preventDefault()
	  }
	  alert(message)
	}
</script>

<template>
	<!-- 특수한 키워드인 $event 사용 -->
	<button @click="warn('아직 양식을 제출할 수 없습니다.', $event)">
	  제출하기
	</button>
	
	<!-- 인라인 화살표 함수 사용 -->
	<button @click="(event) => warn('아직 양식을 제출할 수 없습니다.', event)">
	  제출하기
	</button>
</template>
```

**이벤트 수식어**

- .stop
- .prevent
- .self
- .capture
- .once
- .passive

```js
<!-- 클릭 이벤트 전파가 중지됩니다. -->
<a @click.stop="doThis"></a>

<!-- submit 이벤트가 더 이상 페이지 리로드하지 않습니다. -->
<form @submit.prevent="onSubmit"></form>

<!-- 수식어를 연결할 수 있습니다. -->
<a @click.stop.prevent="doThat"></a>

<!-- 이벤트에 핸들러 없이 수식어만 사용할 수 있습니다. -->
<form @submit.prevent></form>

<!-- event.target이 엘리먼트 자신일 경우에만 핸들러가 실행됩니다. -->
<!-- 예를 들어 자식 엘리먼트에서 클릭 액션이 있으면 핸들러가 실행되지 않습니다. -->
<div @click.self="doThat">...</div>
```

<mark style="background: #FF5582A6;">TIP)</mark>

수정자를 사용할 때는 관련 코드가 동일한 순서로 생성되므로 순서가 중요하다. 
따라서 `@click.prevent.self`를 사용하면 **앨리먼트 자체와 그 자식에 대한 클릭의 기본 동작**을 방지
`@click.self.prevent`는 앨리먼트 자체에 대한 클릭의 기본 동작만 방지합니다.

| 수식어        | 설명               | 사용 예시                     |
| ---------- | ---------------- | ------------------------- |
| `.stop`    | 이벤트 전파 방지        | `@click.stop="fn"`        |
| `.prevent` | 기본 동작 방지         | `@submit.prevent="fn"`    |
| `.self`    | 자신에게서만 이벤트 처리    | `@click.self="fn"`        |
| `.capture` | 캡처링 단계에서 실행      | `@click.capture="fn"`     |
| `.once`    | 한 번만 실행          | `@click.once="fn"`        |
| `.passive` | prevent를 허용하지 않음 | `@touchmove.passive="fn"` |

```js
<!-- 이벤트 리스너를 추가할 때 캡처 모드 사용 -->
<!-- 내부 엘리먼트에서 클릭 이벤트 핸들러가 실행되기 전에, 여기에서 먼저 핸들러가 실행됩니다. -->
<div @click.capture="doThis">...</div>

<!-- 클릭 이벤트는 단 한 번만 실행됩니다. -->
<a @click.once="doThis"></a>

<!-- 핸들러 내 `event.preventDefault()`가 포함되었더라도 -->
<!-- 스크롤 이벤트의 기본 동작(스크롤)이 발생합니다.        -->
<div @scroll.passive="onScroll">...</div>
```

**입력키 수식어**
- 키보드 이벤트를 수신할 때, 특정 키를 확인해야 하는 경우가 많기 때문에, 키 수식어를 지원합니다:

```js

<!-- `key`가 `Enter`일 때만 `submit`을 호출합니다 -->
<input @keyup.enter="submit" />

```

- [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)를 통해 유효한 입력키 이름을 kebab-case로 변환하여 수식어로 사용할 수 있습니다:
```js

<input @keyup.page-down="onPageDown" />

```

**입력키 별칭**
- .enter
- .tab
- .delete ("Delete" 및 "Backspace" 키 모두 캡처)
- .esc
- .space
- .up
- .down
- .left
- .right

**시스템 입력키 수식어**
- 마우스 또는 키보드 이벤트 리스너는 아래 수식어를 사용하여, 해당 입력키를 누를 때만 트리거 되도록 할 수 있습니다:

- .ctrl
- .alt
- .shift
- .meta (맥에서는 커멘트 키, 윈도우에서는 윈도우키...)

```js
<!-- Alt + Enter -->
<input @keyup.alt.enter="clear" />

<!-- Ctrl + Click -->
<div @click.ctrl="doSomething">시작하기</div>
```

<mark style="background: #FF5582A6;">TIP)</mark>
- <mark style="background: #FFF3A3A6;">시스템 수식어 입력키는 일반 키와 다르므로 `keyup` 이벤트와 함께 사용되는 경우, 키가 눌려저 있어야 이벤트가 발생합니다.</mark> 즉, <mark style="background: #FFF3A3A6;">`keyup.ctrl`은 `ctrl`을 누른 상태에서 다른 입력키를 땔 때(key up)만 트리거됩니다. `ctrl` 키만 땔 때는 트리거되지 않습니다.
</mark>



**.exact 수식어**
`.exact` 수식어를 사용하면 이벤트를 트리거하는데 필요한 시스템 수식어의 정확한 조합을 사용해야한다.

```js
<!-- Ctrl과 함께 Alt 또는 Shift를 누른 상태에서도 클릭하면 실행됩니다. -->
<button @click.ctrl="onClick">A</button>

<!-- 오직 Ctrl만 누른 상태에서 클릭해야 실행됩니다. -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 시스템 입력키를 누르지 않고 클릭해야지만 실행됩니다. -->
<button @click.exact="onClick">A</button>

```

**마우스 버튼 수식어**
특정 마우스 버튼에 의해 이벤트가 트리거 되도록 제한하고 싶을 때 사용

- .left
- .right
- .middle

### 9. Form 입력 바인딩
- <mark style="background: #FFF3A3A6;">v-model</mark> 을 사용해서 바인딩한다.

1) v-model을 사용하지 않았을 때
```js
<input
  :value="text"
  @input="event => text = event.target.value">
```

|항목|`input` 이벤트|`change` 이벤트|
|---|---|---|
|**발생 시점**|**입력값이 변경될 때마다 즉시 발생**|**입력 후 포커스가 빠져나갈 때 발생**|
|**트리거 조건**|사용자가 타이핑할 때마다 발생|사용자가 입력을 완료하고 `<input>`에서 포커스를 벗어날 때 발생|
|**실시간 반영**|O (실시간으로 반응 가능)|X (최종 입력값만 반영됨)|
|**사용 예시**|실시간 검색, 자동완성, 글자 수 카운팅 등|최종 유효성 검사, 저장 버튼 활성화 등|
|**v-model 동작**|Vue 3 기준으로 기본적으로 `input` 기반|Vue 2에서는 `input`이지만 `type="checkbox"`나 `select`는 내부적으로 `change` 사용|
|**사용 가능한 요소**|`<input>`, `<textarea>`, `<select>` 등 대부분|주로 `<input>`, `<select>`|
|**이벤트 타이밍 예시**|`onInput` 즉시 실행: `abc` 입력 시 3번 실행됨|`onChange`는 blur 또는 엔터 시 1번 실행됨|

2) v-model을 사용할 때
```js
<input v-model="text">
```

- `v-model`은 다른 유형의 입력인 `<textarea>` `<select>` 엘리먼트에 사용할 수 있다.

| 요소                        | 이벤트     | 속성      |
| ------------------------- | ------- | ------- |
| `input`                   | @input  | value   |
| `textarea`                | @input  | value   |
| `<input type="checkbox">` | @change | checked |
| `<input type="radio">`    | @change | checked |
| `<select>`                | @change | value   |
<mark style="background: #FF5582A6;">NOTE)</mark>
`v-model` will ignore the initial `value`, `checked` or `selected` attributes found on any form elements.
-> v-model은 항상 바인딩된 js 상태를 유효한 값으로 취급한다. (폼 엘리먼트에서 감지되는 초기 value, checkec, selected 속성 값을 무시한다.)

**Basic Usage**

1) 텍스트

```js

<p>메세지: {{ message }}</p>
<input v-model="message" placeholder="메세지 입력하기" />

```

<mark style="background: #FFB8EBA6;">주의</mark> 
- <mark style="background: #FFF3A3A6;">IME가 필요한 언어(중국어, 일본어, 한국어 등) v-model이 업데이트 되지 않는다. 이때는 직접 구현한 input 이벤트 리스너와 value를 바인딩해서 기능을 구성해야 한다.</mark>

```js

<input @input="event => text = event.target.value" :value="text">

```


2) 여러 줄 텍스트

```js

<span>여러 줄 메세지:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<textarea v-model="message" placeholder="여러 줄을 추가해보세요"></textarea>


```

- `<textarea>` 내부에 이중 중괄호 문법은 작동하지 않으므로 `v-model`을 사용해야 합니다.
```

<!-- 잘못된 사례 -->
<textarea>{{ text }}</textarea>

<!-- 올바른 사례 -->
<textarea v-model="text"></textarea>


```

3) 체크박스

<mark style="background: #FFF3A3A6;">단일 체크박스</mark>
```js

<input type="checkbox" id="checkbox" v-model="checked" />
<label for="checkbox">{{ checked }}</label>


```

<mark style="background: #FFF3A3A6;">멀티 체크박스</mark>
- 배열 또는 [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)에 여러 개의 체크박스 값을 바인딩할 수도 있습니다.

```js
<script>
const checkedNames = ref([])
</script>


<template>
	<div>체크된 이름: {{ checkedNames }}</div>
	
	<input type="checkbox" id="jack" value="젝" v-model="checkedNames">
	<label for="jack">젝</label>
	
	<input type="checkbox" id="john" value="존" v-model="checkedNames">
	<label for="john">존</label>
	
	<input type="checkbox" id="mike" value="마이크" v-model="checkedNames">
	<label for="mike">마이크</label>
</template>

```

Set일 때
```js

<script setup>

import { ref, computed } from 'vue'

const checkedSet = ref(new Set())

// 템플릿에서 바인딩하기 쉽게 computed array로 변환
const checkedNames = computed({
	get: () => Array.from(checkedSet.value),
	set: (newValues) => {

		checkedSet.value = new Set(newValues)
	}
})

</script>

  

<template>

	<div>체크된 이름: {{ checkedNames.join(', ') }}</div>

	<input type="checkbox" id="jack" value="젝" v-model="checkedNames" />
	
	<label for="jack">젝</label>
	
	  
	
	<input type="checkbox" id="john" value="존" v-model="checkedNames" />
	
	<label for="john">존</label>
	
	  
	
	<input type="checkbox" id="mike" value="마이크" v-model="checkedNames" />
	
	<label for="mike">마이크</label>
</template>

```

#### Vue에서는 checkbox의 그룹이 배열로 자동으로 바인딩된다.
##### Vue에서는 checkbox의 그룹이 배열로 자동으로 바인딩된다.
###### Vue에서는 checkbox의 그룹이 배열로 자동으로 바인딩된다.

| 요소                         | 설명                                   |
| -------------------------- | ------------------------------------ |
| `v-model`이 같은 checkbox     | Vue가 자동으로 그룹으로 묶음                    |
| `value`가 다르면               | 각 체크박스의 고유 항목으로 구분됨                  |
| 체크된 항목들만                   | `v-model`로 연결된 배열에 자동 추가/삭제됨         |
| `v-model = computed()`인 경우 | `set()`에 선택된 항목 배열이 `newValues`로 들어감 |

##### 결과:

- `잭`, `마이크` 선택 시 → `checkedNames = ['잭', '마이크']`
- `존` 추가 선택 시 → `checkedNames = ['잭', '마이크', '존']`

**radio**

```js

<div>Picked: {{ picked }}</div>

<input type="radio" id="one" value="One" v-model="picked" />
<label for="one">One</label>

<input type="radio" id="two" value="Two" v-model="picked" />
<label for="two">Two</label>

```

**select**
1) Single Select
```js

<div>Selected: {{ selected }}</div>

<select v-model="selected">
  <option disabled value="">Please select one</option>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>
```

<mark style="background: #FFB8EBA6;">NOTE)</mark>
- `v-model` 표현식의 초기 값이 옵션과 일치하지 않으면 `<select>` 엘리먼트가 "선택되지 않은" 상태로 렌더링됩니다. iOS에서는 이 경우 변경 이벤트를 발생시키지 않기 때문에 사용자가 첫 번째 항목을 선택할 수 없게 됩니다. 
<mark style="background: #FFF3A3A6;">-> 따라서 위의 예에서 설명한 것처럼 비활성화된 옵션에 빈 값을 제공하는 것이 좋습니다.</mark>


select 옵션은 `v-for`로 동적으로 렌더링할 수도 있다.
```js

<script>
const selected = ref('1')

const options = ref([
  { text: '하나', value: '1' },
  { text: '둘', value: '2' },
  { text: '셋', value: '3' }
])
</script>

<template>
<select v-model="selected">
  <option v-for="option in options" :value="option.value">
	{{ option.text }}
  </option>
</select>

<div>선택됨: {{ selected }}</div>
</template>

```


2) Multiple Select
```js

<div>Selected: {{ selected }}</div>

<select v-model="selected" multiple>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>

```

**값 바인딩 하기**

- 라디오, 체크박스 및 셀렉트 옵션의 경우, `v-model`에 바인딩된 값은 일반적으로 정적 문자열(체크박스의 경우 불리언)이다.

```js

<!-- `picked`는 선택 시 문자열 "가"입니다. -->
<input type="radio" v-model="picked" value="가" />

<!-- `toggle`은 true 또는 false입니다. -->
<input type="checkbox" v-model="toggle" />

<!-- `selected`는 첫 번째 옵션이 선택될 때 문자열 "한글"입니다. -->
<select v-model="selected">
  <option value="한글">한글</option>
</select>

```

##### <mark style="background: #FFF3A3A6;">체크박스 값은 어떻게 결정되는가?</mark>

| 상황                   | `v-model`의 타입              | 설명                         |
| -------------------- | -------------------------- | -------------------------- |
| `value` 속성이 **없을 때** | `Boolean` (`true`/`false`) | 단일 체크박스로 작동                |
| `value` 속성이 **있을 때** | `String` (혹은 지정한 타입)       | 배열로 항목을 추가/제거 (다중 체크박스 그룹) |

**Checkbox**

- `true-value` 및 `false-value` 속성은 `v-model`을 사용하는 경우에만 작동하는 Vue 전용 속성입니다. 여기에서 `toggle` 속성의 값은 체크박스가 선택되면 `네`로 설정되고 선택되지 않을 때는 `아니오`로 설정됩니다. 이 전용 속성에 `v-bind`(`:`)를 사용하여 동적인 값을 바인딩할 수도 있습니다.

```js
<input
  type="checkbox"
  v-model="toggle"
  true-value="네"
  false-value="아니오" />
```

동적인 값 바인딩도 가능)
```js

<input
  type="checkbox"
  v-model="toggle"
  :true-value="dynamicTrueValue"
  :false-value="dynamicFalseValue" />


```

- 브라우저는 폼 제출 시 체크되지 않은 상자는 포함하지 않기 때문에, `true-value`와 `false-value` 속성은 입력의 `value` 속성에 영향을 주지 않습니다. 두 값 중 하나가 폼으로 제출되도록 하려면(예: "네" 또는 "아니오") 체크박스 대신 라디오로 구현해야 합니다.

**라디오**
```js

<input type="radio" v-model="pick" :value="first" />
<input type="radio" v-model="pick" :value="second" />


```

**셀렉트 옵션**

```js

<select v-model="selected">
  <!-- 인라인 객체 리터럴 -->
  <option :value="{ number: 123 }">123</option>
</select>


```

**수식어**
- `.lazy`
	기본적으로 `v-model`은 각 `input` 이벤트 이후 데이터와 입력을 동기화합니다([위에 언급된 IME 구성 제외](https://v3-docs.vuejs-korea.org/guide/essentials/forms.html#vmodel-ime-tip)). 대신 `change` 이벤트 이후에 동기화하기 위해 `.lazy` 수식어를 추가할 수 있습니다.
	
```js

<!-- "input" 대신 "change" 이벤트 후에 동기화됨 -->
<input v-model.lazy="msg" />

```

- `.number`
	사용자 입력이 자동으로 숫자로 유형 변환되도록 하려면, `v-model` 수식어로 `.number`를 추가하면 됩니다:

```js
<input v-model.number="age" />
```

값을 `parseFloat()`로 파싱할 수 없으면 원래 값이 대신 사용됩니다.

인풋에 `type="number"`가 있으면 `.number` 수식어가 자동으로 적용됩니다.

- `.trim`
사용자 입력의 공백이 자동으로 트리밍되도록 하려면 `v-model` 수식어로 `.trim`을 추가하면 됩니다:

```js
<input v-model.trim="msg" />
```

### 10. 생명주기 훅
- composition api에서 주로 `onMounted`, `onUpdated`, `onUnmounted`

### 11. 감시자 (watchers)
- computed 속성은 선언적으로 값을 반환한다
-> 의존성 값이 바꼈을 때 side effects를 부수적으로 실행해야할 경우가 있다.
(ex: DOM 조작, 비동기 로직 등..)

-> 우리는 watch function을 통해 callback을 실행할 수 있다. (react의 useEffect 같음)

```js

<script setup>
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('질문에는 일반적으로 물음표가 포함됩니다.')

// watch는 ref에서 직접 작동합니다
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.indexOf('?') > -1) {
    answer.value = '생각 중...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer === 'yes' ? '네' : '아니오'
    } catch (error) {
      answer.value = '에러! API에 연결할 수 없습니다. ' + error
    }
  }
})
</script>

<template>
  <p>
    예/아니오 질문:
    <input v-model="question" />
  </p>
  <p>{{ answer }}</p>
</template>

```

**WATCH SOURCE TYPES**

```js

const x = ref(0)
const y = ref(0)

// single ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})

// getter
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)

// array of multiple sources
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})


```

<mark style="background: #FFF3A3A6;">다음과 같이 반응형 객체의 속성을 감시할 수는 없습니다:</mark>

```js

const obj = reactive({ count: 0 })

// 이것은 watch()에 숫자를 전달하기 때문에 작동하지 않습니다.
watch(obj.count, (count) => {
  console.log(`count 값: ${count}`)
})

```

### <mark style="background: #FFF3A3A6;">대신 getter를 사용하십시오:</mark>

```js

watch(
  () => obj.count,
  (count) => {
    console.log(`count 값: ${count}`)
  }
)


```

**Deep Watchers**
- When you call `watch()` directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutation
-> 기본적으로 nested된 객체의 속성이 변하면 wathers가 실행된다.

```js

const obj = reactive({ count: 0 })

watch(obj, (newValue, oldValue) => {
  // fires on nested property mutations
  // Note: `newValue` will be equal to `oldValue` here
  // because they both point to the same object!
})

obj.count++

```

1) Getter 속성 사용해서 watch되는 속성을 줄일 수 있다.

```js

watch(
  () => state.someObject,
  () => {
    // fires only when state.someObject is replaced
  }
)

```

2) You can, however, force the second case into a deep watcher by explicitly using the `deep` option:
```js

watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // Note: `newValue` will be equal to `oldValue` here
    // *unless* state.someObject has been replaced
  },
  { deep: true }
)

```
**위 경우 같은 객체를 참고하고 있기 때문에 newValue, oldValue가 같다. (당연)**

**Eager Watchers**
- `watch` is lazy by default: the callback won't be called until the watched source has changed.
-> watch는 기본적으로 의존성 값이 바뀌지 않으면 실행되지 않는다.
-> 만약 즉시 실행을 원한다면?

```js

watch(source, (newValue, oldValue) => {
  // 즉시 실행된 다음 `source`가 변경되면 다시 실행됩니다.
}, { immediate: true })


```
***VUE 3.4 이후 버전부터 immediate 적용 가능함**


**Once Watchers**
- 만약 한 번만 wather의 callback이 실행되도록 하려면?

```js

watch(
  source,
  (newValue, oldValue) => {
    // when `source` changes, triggers only once
  },
  { once: true }
)

```

**watchEffect()**
- immediate:true 없이 watch의 callback을 무조건 처음에 실행하고 싶다면 watchEffect()를 사용한다.


```js

const url = ref('https://...')
const data = ref(null)

async function fetchData() {
  const response = await fetch(url.value)
  data.value = await response.json()
}

// 즉시 데이터 가져오기
fetchData()
// ...그런다음 url 변경을 감시하도록 watch를 실행합니다.
watch(url, fetchData)


```


```js

const url = ref('https://...')
const data = ref(null)

watchEffect(async () => {
  const response = await fetch(url.value)
  data.value = await response.json()
})

```

| 항목              | `watchEffect()`       | `watch()`         |
| --------------- | --------------------- | ----------------- |
| 추적 방식           | 자동 추적                 | 명시적 추적            |
| `await` 이후 값 추적 | ❌ 안 됨                 | ✅ 문제 없음           |
| 추적 대상 명시 필요     | ❌ 필요 없음               | ✅ 반드시 지정해야 함      |
| 사용 용도           | 여러 반응형 값이 있을 때 빠르게 반응 | 특정 값 감시, 비동기 콜백 등 |

### `watch` vs. `watchEffect`[#](https://v3-docs.vuejs-korea.org/guide/essentials/watchers.html#watch-vs-watcheffect)

`watch`와 `'watchEffect`' 둘 다 사이드 이펙트를 반응적으로 실행할 수 있게 해줍니다. 주요 차이점은 반응형 의존성을 추적하는 방식입니다:

- `watch`는 명시적으로 감시된 소스만 추적합니다. 콜백 내에서 조회하는 항목은 추적하지 않습니다. 또한 콜백은 소스가 실제로 변경된 경우에만 트리거됩니다. `watch`는 의존성 추적을 사이드 이펙트와 분리하여, 콜백이 실행되어야 하는 시기를 보다 정확하게 제어할 수 있습니다.
    
- 반면 `watchEffect`는 의존성 추적과 사이드 이펙트를 하나의 단계로 결합합니다. 동기적(sync) 실행 중에 조회되는 모든 반응형 속성을 자동으로 추적합니다. 이것은 더 편리하고 일반적으로 더 간결한 코드를 생성하지만, 콜백이 실행되어야 하는 시기가 덜 명시적입니다.



### 12. 템플릿 참조
### 13. 컴포넌트 기초
