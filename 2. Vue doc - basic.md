
### 1. 앱 만들기

- **react 처럼 id app에 마운트된다.**
- 메인 소스에서 app.component('TestComponent', TestComponent) 선언하면, **전역 컴포넌트 설정 가능**
- **메인 소스에서 전역 에러 캡처링도 가능** 
- 멀티 앱 인스턴스

```ts
	app.config.errorHandler = (err) => {
	/* 에러 처리 */
	console.log('error', err)
	}
```

```html
<!DOCTYPE html>

<html lang="">
<head>
	<meta charset="UTF-8">
	<link rel="icon" href="/favicon.ico">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Vite App</title>
</head>

<body>
	<div id="app"></div>
		<script type="module" src="/src/main.ts"></script>
	</body>
</html>

```

```ts

import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import TestComponent from './components/TestComponent.vue'

const app = createApp(App)

app.config.errorHandler = (err) => {
/* 에러 처리 */
console.log('error', err)
}

app.component('TestComponent', TestComponent)

app.use(router)



  
// 마운트
app.mount('#app')
```

### 2. 템플릿 문법
- **리액트랑 거의 유사하다, 단 {{}} 이중괄호**

1) HTML 출력
react의 dangerousSetInnterHTML 처럼, v-html 사용
```
<p>텍스트 보간법 사용: {{ rawHtml }}</p> 
<p>v-html 디렉티브 사용: <span v-html="rawHtml"></span></p>


텍스트 보간법 사용: <span style="color: red">이것은 빨간색이어야 합니다.</span>
v-html 디렉티브 사용: 이것은 빨간색이어야 합니다.

```

2) 속성 바인딩
- **이중괄호는 HTML 속성(attribute) 내에서 사용할 수 없다! 대신 v-bind 디렉티브를 사용해라**
- 바인딩된 값이 null 또는 undefined이면 엘리먼트의 속성이 제거된 상태로 렌더된다.

```html

<div v-bind:id="dynamicId"></div>

```

**단축 문법**
```html

<div :id="dynamicId"></div>

```

**동일 이름 축약**
- 속성의 이름이 바인딩되는 자바스크립트의 값과 같을 경우, 속성 값 생략을 통해 문법을 더욱 간소화 할 수 있다.
```html

<!-- :id="id" 와 동일 -->
<div :id></div>

<!-- 이것도 작동합니다 -->
<div v-bind:id></div>
<div v-bind:id="id"></div>

```

**불리언(Boolean) 속성**
- [불리언 속성](https://html.spec.whatwg.org/multipage/common-microsyntaxes#boolean-attributes)은 엘리먼트에 표기했는지 여부로 참/거짓 값을 나타내는 속성입니다. 예를 들어, [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled)는 가장 일반적으로 사용되는 불리언 속성 중 하나입니다.

```html

<button :disabled="isButtonDisabled">버튼/button>

```

`isButtonDisabled`에 [truthy 값](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)이 있는 경우, `disabled` 속성이 표기됩니다. 값이 빈 문자열인 경우 `<button disabled="">`의 일관성을 유지하므로 속성이 표기됩니다. 그 외 [falsy 값](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)의 경우 속성이 생략됩니다.

**여러 속성을 동적으로 바인딩**

```ts

const objectOfAttrs = 
{ id: 'container', class: 'wrapper', style: 'background-color:green' }

```

```html

<div v-bind="objectOfAttrs"></div>

```


2) JavaScript 표현식 사용

**표현식 사용**
```ts

{{ number + 1 }}

{{ ok ? '예' : '아니오' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>

```

**함수호출**
- 바인딩 표현식 내부에서 컴포넌트에서 노출하는 메서드를 호출할 수 있다.

```typescript

<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>

```

**제한된 전역 접근**
- 템플릿 표현식은 샌드박스 처리되어 [제한된 전역 리스트](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3)에만 접근할 수 있습니다. 이 목록은 `Math` 및 `Date` 등 일반적으로 사용되는 기본 제공 전역 객체를 표시합니다.
- 리스트에 명시적으로 포함되지 않은 `window`와 같은 전역 속성은 템플릿 표현식에서 접근할 수 없습니다. 그러나 [`app.config.globalProperties`](https://ko.vuejs.org/api/application.html#app-config-globalproperties)에 추가하여, Vue 내부의 모든 표현식에서 전역 속성에 접근 할 수 있도록 명시적으로 정의할 수 있습니다.

템플릿 안에서 window 접근하면 요래됨

![[Pasted image 20250604134839.png]]

2) 디렉티브
- v- 접두사가 있는 특수한 속성을 디렉티브라 한다. Vue는 위에서 언급한 v-html, v-bind를 포함하여 빌트인 디렉티브를 제공한다.
- **디렉티브의 속성 값은 단일 JavaScript 표현식이어야 한다(v-for, v-on, v-slot 제외)**
- 디렉티브의 역할을 표현식 값이 변경될 때 DOM에 반응적으로 업데이트를 적용하는것
- **디렉티브의 인자를 대괄호로 감싸서 JavaScript 표현식으로 사용할 수도 있습니다:**

**인자** 
일부 디렉티브는 디렉티브 뒤에 콜론(`:`)으로 표시되는 "인자"를 사용할 수 있습니다. 예를 들어 `v-bind` 디렉티브는 HTML 속성을 반응적으로 업데이트하는 데 사용됩니다:

```html
<a v-bind:href="url"> ... </a>

<!-- 단축 문법 -->
<a :href="url"> ... </a>
```

```html
<a v-on:click="doSomething"> ... </a>
<!-- 단축 문법 -->
<a @click="doSomething"> ... </a>
```

**동적인 인자**
- 디렉티브의 인자를 대괄호로 감싸서 JavaScript 표현식으로 사용할 수도 있습니다:
- 동적인 인자 값 제약 조건[​](https://ko.vuejs.org/guide/essentials/template-syntax.html#dynamic-argument-value-constraints)
	**동적인 인자는 `null` 또는 문자열로 평가되어야 합니다. 값이 `null`일 경우, 바인딩을 명시적으로 제거합니다. 문자열이 아닌 다른 값은 에러를 트리거합니다.**
- 동적인 인자 문법 제약 조건
```html

<!-- 이렇게 하면 컴파일러 경고가 트리거됩니다. -->
<a :['foo' + bar]="value"> ... </a>

```
- DOM 내 템플릿(HTML 파일에 직접 작성된 템플릿)을 사용할 때, 브라우저가 속성 이름을 소문자로 강제 변환하므로 대문자로 키 이름을 지정하는 것도 피해야 합니다:

```html

<a :[someAttr]="value"> ... </a>

```

위의 내용은 DOM 내 템플릿에서 `:[someattr]`로 변환됩니다. 컴포넌트에 `someattr` 대신 `someAttr` 속성을 사용했다면 코드가 작동하지 않습니다. 싱글 파일 컴포넌트 내의 템플릿은 이 제약 조건에 해당하지 않습니다.

대문자로 속성이 들어가도, 소문자로 자동으로 파싱된다(무적권)
```vue

<script setup lang="ts">
const triggerError = () => {
// throw new Error('error')
console.log(window)
}

  

const LINK = 'HrEF'
const route = '/home'
</script>

  

<template>
	<a :[LINK]="route"> ... </a>
</template>

```

![[Pasted image 20250604140612.png]]
```html
<!--
아래의 "동적인 인자 값 제약 조건" 및 "동적인 인자 문법 제약 조건" 섹션에 설명된 대로,
인자 표현식에는 몇 가지 제약 사항이 있음에 유의하십시오.
-->
<a v-bind:[attributeName]="url"> ... </a>

<!-- 단축 문법 -->
<a :[attributeName]="url"> ... </a>

```

```html

<a v-on:[eventName]="doSomething"> ... </a>

<!-- 단축 문법 -->
<a @[eventName]="doSomething"> ... </a>

```

3) 수식어
- 수식어는 점(`.`)으로 시작하는 특수한 접미사로, 디렉티브가 특별한 방식으로 바인딩되어야 함을 나타냅니다. 예를 들어 `.prevent` 수식어는 트리거된 이벤트에서 `event.preventDefault()`를 호출하도록 `v-on` 디렉티브에 지시합니다.

```html
<form @submit.prevent="onSubmit">...</form>
```

![[Pasted image 20250604141017.png]]
### 3. 반응형 기초

1) reactive

- react의 useState와 다른점: 불변성 개념이 없다.
**(Vue는 기본적으로 반응형 상태를 내부 깊숙이 추적하므로, 중첩된 객체나 배열을 변경할 때에도 변경 사항이 감지된다)**
- reactive는 원시값을 사용할 수 없다(객체, 배열, Map, Set)과 같은 컬렉션 유형에만 사용가능
- 반응형 객체의 속성을 로컬 변수에 할당하거나 분해 할당 또는 함수에 전달할 때 반응형 연결이 끊어짐을 의미합니다.

```ts

const state = reactive({ count: 0 })

// n은 state.count에서 연결이 끊긴 로컬 변수입니다.
let n = state.count
// 원본의 상태(state.count)에 영향을 미치지 않습니다.
n++

// 로컬 변수 count는 state.count로부터 연결이 끊깁니다.
let { count } = state
// 원본의 상태(state.count)에 영향을 미치지 않습니다.
count++

// 함수는 일반적인 숫자를 수신하며,
// state.count의 변경 사항을 감지할 수 없습니다.
callSomeFunction(state.count)

```

```ts

import {reactive} from 'vue';

const state = reactive({ count: 0})

```

```ts

<script setup>
import { reactive } from 'vue'

const state = reactive({ count: 0 })

function increment() {
  state.count++
}
</script>

<template>
  <button @click="increment">
    {{ state.count }}
  </button>
</template>

```

**DOM 업데이트 타이밍**
DOM 업데이트는 동기적으로 업데이트 되지 않는다.

```ts

import { nextTick } from 'vue'

function increment() {
  state.count++
  nextTick(() => {
    // 업데이트된 DOM에 접근 가능
  })
}

```

**깊은 반응형**

#### **Vue는 기본적으로 반응형 상태를 내부 깊숙히 추적하므로, 충접된 객체나 배열을 변경할 때에도 변경 사항이 감지된다.**
##### **Vue는 기본적으로 반응형 상태를 내부 깊숙히 추적하므로, 충접된 객체나 배열을 변경할 때에도 변경 사항이 감지된다.**
###### **Vue는 기본적으로 반응형 상태를 내부 깊숙히 추적하므로, 충접된 객체나 배열을 변경할 때에도 변경 사항이 감지된다.**

```ts

import { reactive } from 'vue'

const obj = reactive({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // 변경 사항이
  obj.nested.count++
  obj.arr.push('baz')
}

```

만약 root 수준에서만 반응성을 추적하는 얕은 반응형 객체를 명시적으로 선언하려면 (shallowReactive)

**반응형 재정의 vs 원본**
reactive()의 반환 값은 원본 객체와 같지 않고 원본 객체를 재정의한 Proxy 객체를 반환한다.

```ts
const raw = {}
const proxy = reactive(raw)

// 반응형으로 재정의 된 것은 원본과 같지 않습니다.
console.log(proxy === raw) // false
```

#### 1) 원본 객체를 업데이트하면, Proxy 객체도 업데이트 된다.(단 리렌더링은 안된다.)
#### 2) Proxy 객체를 업데이트 하면 리렌더링 된다.

```ts


<script setup>

import { ref, reactive } from 'vue'

const testObj = {number: 0};
const test1 = reactive(testObj)

const checkValue = () => {
	console.log("testObj", testObj)
	console.log("test1", test1)
}

const updateOriginValue = () => {
	testObj.number +=1;
}

const updateReactiveValue = () => {
	test1.number+=1;
}

</script>

<template>
	<h2>{{test1.number}}</h2>
	<button @click="checkValue">checkValue</button>
	<button @click="updateOriginValue">updateOriginValue</button>
	<button @click="updateReactiveValue">updateReactiveValue</button>
</template>

```

#### 3) Proxy를 Proxy하면 동일한 Proxy를 반환한다.
```ts

const raw = {}
const proxy = reactive(raw)

// 반응형으로 재정의 된 것은 원본과 같지 않습니다.
console.log(proxy === raw) // false

// 객체를 reactive() 한 반환 값과 프락시는 동일합니다.
console.log(reactive(raw) === proxy) // true

// 프락시를 reactive()한 반환 값과 프락시는 동일합니다.
console.log(reactive(proxy) === proxy) // true



```

#### 4) 3의 중첩 규칙은 중첩된 객체에도 적용된다. (내부 깊숙이까지 반응형이므로 반응형 객체 내부의 중첩된 객체도 프록시다.) 

```ts
const proxy = reactive({})

const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false

```

2) ref
- reactive의 자료형 제약사항을 해결하기 위해 어떠한 데이터라도 반응형으로 재정의 할 수 있다.

```ts

import { ref } from 'vue'

const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

```

### 4. 계산된 속성
### 5. 클래스와 스타일 바인딩
### 6. 조건부 렌더링
### 7. 리스트 렌더링
### 8. 이벤트 핸들링
### 9. Form 입력 바인딩
### 10. 감시자
### 11. 템플릿 참조
### 12. 컴포넌트 기초
### 13. 생명주기 훅
