
[[1. 변수와 자료형]]
[[2. 여러가지 연산자]]
[[3. 제어 흐름 이해하기]]
[[4. 클래스와 객체1]]
[[5. 클래스와 객체2]]
[[6. 배열과 ArrayList ]]
[[8. 상속과 다형성]]
[[9. 추상 클래스]]
[[ 10. 인터페이스]]
[[11. JDK 기본 클래스]]
[[12. 컬렉션 프레임워크]]
[[13. 내부 클래스, 람다식, 스트림]]
[[14. 예외 처리]]
[[15. 자바 입출력]]
[[16. 스레드]]


### 1. About JAVA

**자바는 한 번 작성하면, 어디서든 돌아간다(Write once, run anywhre)**
-> 플랫폼에 종속되지 않는 프로그램


Case 1: C언어

Text.c 라는 C 코드를 윈도우에서 컴파일하면 Test.exe 라는 **실행 파일**이 만들어진다.

Test.exe는 리눅스에서 실행 불가하다. (리눅스에서 Text.c 파일을 다시 컴파일해서 실행 파일을 만들어야 한다.)

Case 2: Java

자바에서 Example.java 코드를 컴파일 하면 Example.class 파일이 생성된다.
-> 이 파일은 바이트 코드라고 하는데, 완벽한 실행 파일이 아니다. 운영 체제에 맞는 완벽한 기계어가 아닌 중간 기계어

-> 이 바이트 코드를 실행하려면 자바 가상 머신(Java Virtual Machine: JVM)이 필요하다.
윈도우용 JVM, 리눅스용 JVM....

초기에는 JVM으로 한번 더 기계어로 변환하기 때문에 속도가 느렸지만, 현재는 JIT 컴파일 방식으로 개선되어 자바 프로그램의 실행 속도는 아무 문제 없다.

#### 용어정리
- JVM : 자바 가상 머신 , \*.class 파일을 실행해서 운영체제에 맞는 기계어로 변환해주는 가상 머신
- JRE: Java Runtime Environment 자바 실행 환경으로, JRE가 설치되어 있으면 JVM도 설치 되어 있다.
- JIT: Just In Time 컴파일러, 실행 시점에 기계어를 생성하는데 같은 코드가 반복되면 매번 기계어를 생성하지 않고 이전에 만든 기계어를 재사용한다.

### 2. 숫자

보수: 보충해주는 수
10진수에서 10의 보수는 더해서 10이 되는 수
2진수에서 2의 보수는 더해서 10이 되는 수

0B0011 의 2의 보수는?
0B1101

더하면 [1]0000 4비트만 사용하는 컴퓨터라면 1이 사라져서 0이된다/
**즉, 2진수에서 2의 보수를 음수라고 한다.**

2의 보수를 구하는 방법?
-> 1의 보수를 구해서 1을 더하면 된다.


### 3. 자료형

| 바이트 수 | 정수형   | 문자형  | 실수형    | 논리형     |
| ----- | ----- | ---- | ------ | ------- |
| 1바이트  | byte  |      |        | boolean |
| 2바이트  | short | char |        |         |
| 3바이트  | int   |      | float  |         |
| 4바이트  | long  |      | double |         |

1바이트 (-128 ~ 127)
2바이트(-32,768 ~ 32,767)
3바이트(-2,147,482,648 ~ 2,147,483,647)
4바이트 ~~

```java

int a = 100;

long b = 200L;

long c = a + b;

System.out.println("값: " + c);

// 자료형 출력 (Wrapper 클래스 이용)

System.out.println("자료형: " + ((Object)c).getClass().getSimpleName());

// 값: 300
// 자료형: Long

```

문자형 자료형:
컴퓨터는 0과 1로만 표현할 수 있으므로, 문자 역시 0과 1로 나타내야 한다.
-> 어떤 문자를 컴퓨터 내부에서 표현하려면 특정 정숫값으로 정하자고 약속함.

문자를 정해진 코드값으로 변환하는 것을 Encoding 인코딩
코드를 다시 문자로 변환하는 것을 Decoding 디코딩

-> 가장 기본이 되는 문자 인코딩은 ASCII 아스키 코드다.
(아스키코드는 알파벳, 숫자, 특수문자, 기호 등을 보함해 1바이트 256개 표현가능하므로 아스키 코드는 1바이트만 사용한다.)

-> 한글과 다른 언어 문자는 복잡하고 다양해서 1바이트만으로 모든 문자를 표현하기 어렵다. 그래서 2바이트 이상을 사용하며, 각 언어의 표준 인코딩을 정의해 놓은 것이 유니코드(unicode)
-> 유니코드에서 1바이트인 값들은 아스키 코드와 호환된다.

Java의 char 형은 유니코드를 기반하기 떄문에 2바이트.
